use std::io;
use sxd_document::parser::parse;
use sxd_xpath::Context;
use sxd_xpath::nodeset::Node;
use why_sxd::{make_xpath, make_xpath_static, xpath_nodes, xpath_nodes_str, attr_u32, attr_hexbyte,
              only_match, only_match_str};

use super::TmxError;

use spr::*;
use level::{self, Level, PScrGrid};

pub fn read_level<R: io::Read>(source: &mut R) -> Result<Level, TmxError> {
    let pkg = {
        let mut buf = String::new();
        source.read_to_string(&mut buf).unwrap();
        parse(&buf).map_err(|_| "bad TMX file")?
    };
    let doc = pkg.as_document();
    let root_node = doc.root().into();
    let ctx = Context::new();

    let first_gid_fg = not_nan(
        make_xpath_static("/map/tileset[@name='fg']/@firstgid")
            .evaluate(&ctx, root_node)?
            .number(),
    ).ok_or("couldn't get first tile for fg; tileset 'fg' may be missing")? as u16;

    let mut fg = read_block_grid(&ctx, root_node, "Level", first_gid_fg)?;
    let bg = read_block_grid(&ctx, root_node, "BG", first_gid_fg)?;

    let map = xpath_nodes_str(&ctx, root_node, "map")
        .unwrap()
        .document_order_first()
        .unwrap();
    let sprs = read_sprite_layer(&ctx, &map)?;
    level::place_sprites(&mut fg, &sprs);

    let sf = read_scroll_filter(&ctx, root_node)?;

    let lvl = Level::from_layers(fg, bg, sf);

    Ok(lvl)
}


fn not_nan(x: f64) -> Option<f64> {
    if !x.is_nan() { Some(x) } else { None }
}

fn read_block_grid(
    context: &Context,
    node: Node,
    name: &'static str,
    firstgid: u16,
) -> Result<PScrGrid, TmxError> {
    let tiles = read_block_layer(context, node, name, firstgid)?;
    Ok(level::pscreens_from_linear_tiles(&tiles, 32, 32))
}


fn read_block_layer(
    context: &Context,
    node: Node,
    name: &'static str,
    firstgid: u16,
) -> Result<Vec<u16>, TmxError> {
    let layer_path = make_xpath(&format!("/map/layer[@name='{}']", name))?;

    let layer = only_match(context, node, &layer_path)
        .ok_or_else(|| format!("need exactly 1 layer named {}", name))?;

    Ok(read_tiles(context, &layer, firstgid).unwrap())
}

fn read_scroll_filter(context: &Context, node: Node) -> Result<Vec<bool>, TmxError> {
    let layer_path = make_xpath_static("/map/layer[@name='Scroll']");

    let layer = only_match(context, node, &layer_path)
        .ok_or("need exactly 1 layer named \"Scroll\"")?;

    // We can use a fake first GID because we donâ€™t care at all what kind of tile we find,
    // only whether tiles exist or not.
    let tiles = read_tiles(context, &layer, 1)?;

    let mut filt = vec![false; 1024];

    // iterate over screens
    for i in 0..filt.len() {
        let sx = i % 32;
        let sy = i / 32;

        // iterate over tiles in the screen
        for y in 0..16 {
            for x in 0..16 {
                let tile_idx = (sy * 16 + y) * 512 + (sx * 16 + x);
                if tiles[tile_idx] != 0x0025 {
                    filt[i] = true;
                    break;
                }
            }
        }
    }

    Ok(filt)
}

fn read_tiles(context: &Context, layer: &Node, firstgid: u16) -> Result<Vec<u16>, TmxError> {

    if attr_u32(layer, "width") != Some(512) || attr_u32(layer, "height") != Some(512) {
        return Err("all layers need to be 512x512".into());
    };

    let data = if let Some(v) = only_match_str(context, *layer, "data").and_then(|n| n.element()) {
        v
    } else {
        return Err("a <layer> is badly formatted".into());
    };

    let encoding = data.attribute("encoding").map(|a| a.value()).unwrap_or(
        "xml",
    );

    let mut tiles = Vec::with_capacity(512 * 512);

    match encoding {
        //"xml" => read_tiles_xml(context, layer, &mut tiles, firstgid)?,
        "csv" => read_tiles_csv(layer, &mut tiles, firstgid)?,
        s => {
            return Err(
                format!("a <layer> has an unsupported encoding (encoding=\"{}\")", s).into(),
            )
        }
    };

    if tiles.len() < 512 * 512 {
        Err("a <layer> has too few tiles for its dimensions".into())
    } else if tiles.len() > 512 * 512 {
        Err("a <layer> has too many tiles for its dimensions".into())
    } else {
        Ok(tiles)
    }
}

fn tile_val(n: u16, first: u16) -> u16 {
    if n != 0 { n - first } else { 0x0025 }
}

/*
fn read_tiles_xml(context: &Context, layer: &Node, buf: &mut Vec<u16>, firstgid: u16)
-> Result<(), TmxError> {
	unimplemented!()
}
*/

fn read_tiles_csv(layer: &Node, buf: &mut Vec<u16>, firstgid: u16) -> Result<(), TmxError> {
    let s = layer.string_value();
    for chunk in s.split(',') {
        let core = chunk.trim();
        let value = core.parse::<u16>().map_err(|_| "invalid tile ID")?;
        buf.push(tile_val(value, firstgid));
    }
    Ok(())
}

fn read_sprite_layer(context: &Context, map: &Node) -> Result<SprSet, TmxError> {
    let mut sprlist = SprSet::new();

    let firstgid = not_nan(
        make_xpath_static("tileset[@name='sprites']/@firstgid")
            .evaluate(&context, *map)?
            .number(),
    ).ok_or("couldn't find first tile for sprites; tileset 'sprites' may be missing")? as u16;

    for node in xpath_nodes_str(&context, *map, "objectgroup[@name='Sprites']/object")? {
        sprlist.insert(sprite_from_node(&context, &node, firstgid)?);
    }

    Ok(sprlist)
}

fn sprite_from_node(
    context: &Context,
    node: &Node,
    firstgid: u16,
) -> Result<SpritePlacement, TmxError> {
    let path = make_xpath_static("properties/property");

    let mut xbit = false;
    let mut xbytes = [0; 4];

    for prop_node in xpath_nodes(context, *node, &path)? {
        let name = prop_node
            .element()
            .unwrap()
            .attribute("name")
            .unwrap()
            .value();
        match name {
            "ebit" => xbit = attr_hexbyte(&prop_node, "value").unwrap_or(0) != 0,
            "xb1" => xbytes[0] = attr_hexbyte(&prop_node, "value").unwrap_or(0),
            "xb2" => xbytes[1] = attr_hexbyte(&prop_node, "value").unwrap_or(0),
            "xb3" => xbytes[2] = attr_hexbyte(&prop_node, "value").unwrap_or(0),
            "xb4" => xbytes[3] = attr_hexbyte(&prop_node, "value").unwrap_or(0),
            x => return Err(format!("Invalid sprite property: {}", x).into()),
        };
    }

    let id = attr_u32(node, "gid").ok_or("A sprite has an invalid ID")? as u16 - firstgid;
    // x + 16, y - 16 is the center of a 32x32 square
    let pos_x = (attr_u32(node, "x").ok_or("A sprite has an invalid X pos")? + 16) as u16 / 16;
    let pos_y = (attr_u32(node, "y").ok_or("A sprite has an invalid Y pos")? - 16) as u16 / 16;

    Ok(SpritePlacement::new(id, pos_x, pos_y, xbit, xbytes))
}

