#![allow(dead_code, unused_variables)]
use std::io;
use level::{Level, ScreenDex};

use super::EncodeError;
use super::rle;

// This module is not optimized.

pub struct LevelWrOfs {
    begin: u32,
    dex: u32,
    screens: u32,
    sprites: u32,
    pal: u32,
    end: u32,
}

pub fn write_level_body<W: io::Write>(dest: &mut W, level: &Level, base_addr: u32)
-> Result<LevelWrOfs, EncodeError> {
    let ref screendex = ScreenDex::from_level(level);
    // we need to skip 8 bytes as a "hole" for pointers
    dest.write_all(&[0; 8]).unwrap();
    let dex = base_addr + 8;
    let screens = dex + write_dex(dest, screendex)?;
    let sprites = screens + write_screens(dest, screendex)?;
    let pal = {
        // add a padding byte if the palette is unaligned
        let end_of_sprites = sprites + write_sprites(dest, screendex)?;
        if end_of_sprites & 1 == 1 { end_of_sprites + 1 } else { end_of_sprites }
    };
    let end = pal + write_pal(dest, level)?;
    
    Ok(LevelWrOfs {begin: base_addr, dex, screens, sprites, pal, end})
}

pub fn write_level_header<W: io::Write>(dest: &mut W, level: &Level) -> Result<(), EncodeError> {
    Ok(())
}

pub fn bin_level(level: &Level, base_addr: u32) -> Result<(Vec<u8>, LevelWrOfs), EncodeError> {
    // 0x400 for screen dexes, 0x200 for palette,
    // 0x1000 as a guess for the remainder
    let mut v = Vec::with_capacity(0x400 * 2 + 0x200 + 0x1000);
    let wr_ofs = write_level_body(&mut v, level, base_addr)?;
    v.shrink_to_fit();
    Ok((v, wr_ofs))
}


fn write_dex<W: io::Write>(dest: &mut W, dex: &ScreenDex) -> Result<u32, EncodeError> {
    let bytes = dex.dex_bytes();
    dest.write_all(&bytes).unwrap();
    Ok(bytes.len() as u32)
}

fn write_screens<W: io::Write>(dest: &mut W, dex: &ScreenDex) -> Result<u32, EncodeError> {
    let tile_bytes = dex.tile_bytes();
    let mut buf: [u8; 3];
    let mut length = 0;
    // this could plausibly be split off into a function,
    // but would require a lot of intermediate types for iterators.
    for run in rle::make_runs(tile_bytes.iter().map(|v| *v)) {
        buf = [
            run.length as u8,
            (run.length >> 8) as u8,
            run.val,
        ];
        dest.write_all(&buf).unwrap(); // this is not great
        length += buf.len() as u32;
    }
    dest.write_all(&[0, 0]).unwrap();
    length += 2;
    Ok(length)
}

fn write_sprites<W: io::Write>(dest: &mut W, dex: &ScreenDex) -> Result<u32, EncodeError> {
    // This size guess is precisely the maximum.
    let mut spriteofs = Vec::with_capacity(0x100);
    // This size guess is enough for exactly one sprite per screen.
    let mut spritebin = Vec::with_capacity(dex.screens.len() * 4);
    let terminator = &[0x80, 0, 0, 0];
    spritebin.extend_from_slice(terminator);
    
    let mut spriteind = 0;
    for scr in dex.screens.iter() {
        if scr.sprites.len() == 0 {
            spriteofs.extend_from_slice(&[0, 0]);
        } else {
            spriteofs.push(((spritebin.len() / 4) as u8) << 1);
            spriteofs.push(spriteind);
            for spr in scr.sprites.iter() {
                spritebin.extend(&spr.to_bytes());
                spriteind += 1;
            }
            spritebin.extend(terminator);
        }
    }
    
    spriteofs.resize(0x100, 0);
    
    dest.write_all(spriteofs.as_slice()).unwrap();
    dest.write_all(spritebin.as_slice()).unwrap();
    Ok(spriteofs.len() as u32 + spritebin.len() as u32)
}

fn write_pal<W: io::Write>(dest: &mut W, level: &Level) -> Result<u32, EncodeError> {
    for _ in 0 .. 16 {
        let mut c = 0x0000;
        for _ in 0 .. 16 {
            let (cl, ch) = (c as u8, (c >> 8) as u8);
            dest.write_all(&[cl, ch]).unwrap();
            // +2 on b, g, r
            c += 0b00010_00010_00010;
        }
    }
    Ok(0x200)
}

